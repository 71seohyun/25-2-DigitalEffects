<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ì œìŠ¤ì²˜ ì¸ì‹ ë“œë¡œì‰ ìë£Œ ìƒì„±ê¸°</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; display: flex; }
        
        /* ì™¼ìª½: ì›¹ìº  í”¼ë“œ */
        #webcam-container { position: absolute; top: 10px; left: 10px; z-index: 10; width: 320px; height: 240px; border: 2px solid #fff; border-radius: 8px; overflow: hidden; background: #000; }
        #input_video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); } /* ê±°ìš¸ ëª¨ë“œ */
        
        /* ì¹´ìš´íŠ¸ë‹¤ìš´ ì˜¤ë²„ë ˆì´ */
        #countdown-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; font-size: 80px; color: white; font-weight: bold; text-shadow: 2px 2px 4px #000; pointer-events: none; display: none; }

        /* ì˜¤ë¥¸ìª½: 3D ë·°ì–´ (ë©”ì¸ í™”ë©´) */
        #canvas-container { width: 100%; height: 100%; }

        /* ì»¨íŠ¸ë¡¤ íŒ¨ë„ */
        #controls { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; z-index: 20; background: rgba(0,0,0,0.6); padding: 15px; border-radius: 30px; }
        button { padding: 10px 20px; border: none; border-radius: 20px; font-size: 16px; cursor: pointer; transition: 0.2s; font-weight: bold; }
        .btn-mode { background: #4facfe; color: white; }
        .btn-save { background: #ff5858; color: white; }
        button:hover { transform: scale(1.05); opacity: 0.9; }

        /* ì•ˆë‚´ ë¬¸êµ¬ */
        #instruction { position: absolute; top: 20px; right: 20px; color: #fff; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; max-width: 300px; line-height: 1.5; pointer-events: none; }
    </style>
</head>
<body>

    <!-- ì•ˆë‚´ ë¬¸êµ¬ -->
    <div id="instruction">
        ğŸ– <b>ì‚¬ìš©ë²•</b><br>
        1. ì›¹ìº ì— ì†ë°”ë‹¥ì„ ë³´ì—¬ì£¼ì„¸ìš”.<br>
        2. 3ì´ˆ ë’¤ ì‚¬ì§„ì´ ì°í™ë‹ˆë‹¤.<br>
        3. ë§ˆìš°ìŠ¤ë¡œ ë“œë˜ê·¸í•˜ì—¬ ê°ë„ë¥¼ ì¡°ì ˆí•˜ì„¸ìš”.<br>
        4. 'ëª¨ë“œ ì „í™˜'ìœ¼ë¡œ ì„ í™”ë¥¼ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    </div>

    <!-- ì›¹ìº  ë° ì œìŠ¤ì²˜ ì¸ì‹ ì˜ì—­ -->
    <div id="webcam-container">
        <video id="input_video" autoplay playsinline></video>
        <div id="countdown-overlay"></div>
    </div>

    <!-- 3D ê²°ê³¼ë¬¼ ë·°ì–´ -->
    <div id="canvas-container"></div>

    <!-- ë²„íŠ¼ë“¤ -->
    <div id="controls">
        <button class="btn-mode" id="toggleBtn">ğŸ¨ ì„ í™” ëª¨ë“œ ì „í™˜</button>
        <button class="btn-save" id="saveBtn">ğŸ’¾ í˜„ì¬ ì¥ë©´ ì €ì¥</button>
    </div>

    <!-- ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë“œ -->
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        // --- 1. ì „ì—­ ë³€ìˆ˜ ì„¤ì • ---
        const videoElement = document.getElementById('input_video');
        const countdownElement = document.getElementById('countdown-overlay');
        const toggleBtn = document.getElementById('toggleBtn');
        const saveBtn = document.getElementById('saveBtn');
        
        let isCountingDown = false;
        let isLineArtMode = false;
        let capturedTexture = null;

        // --- 2. Three.js ì„¤ì • (3D ë·°ì–´) ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x333333);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 3;

        const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true }); // saveë¥¼ ìœ„í•´ preserveDrawingBuffer í•„ìˆ˜
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // ì¡°ëª…
        const ambientLight = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambientLight);

        // í‰ë©´ ë©”ì‰¬ ìƒì„± (ì‚¬ì§„ì´ ì…í˜€ì§ˆ ê³³)
        // ê¸°ë³¸ 4:3 ë¹„ìœ¨ ê°€ì •
        const geometry = new THREE.PlaneGeometry(2.4, 1.8); 
        
        // ì‰ì´ë” ë¨¸í‹°ë¦¬ì–¼ (ì„ í™” ì¶”ì¶œìš© & ê¸°ë³¸ìš© í†µí•©)
        // Sobel Operatorë¥¼ ì´ìš©í•œ ì—£ì§€ ë””í…ì…˜ ì‰ì´ë”
        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            uniform sampler2D tDiffuse;
            uniform float uIsLineArt; // 0: ì»¬ëŸ¬, 1: ì„ í™”
            uniform vec2 uResolution;
            varying vec2 vUv;

            void main() {
                vec4 color = texture2D(tDiffuse, vUv);

                if (uIsLineArt > 0.5) {
                    // Sobel Edge Detection
                    float w = 1.0 / uResolution.x;
                    float h = 1.0 / uResolution.y;

                    vec4 n[9];
                    n[0] = texture2D(tDiffuse, vUv + vec2( -w, -h));
                    n[1] = texture2D(tDiffuse, vUv + vec2(0.0, -h));
                    n[2] = texture2D(tDiffuse, vUv + vec2(  w, -h));
                    n[3] = texture2D(tDiffuse, vUv + vec2( -w, 0.0));
                    n[4] = texture2D(tDiffuse, vUv);
                    n[5] = texture2D(tDiffuse, vUv + vec2(  w, 0.0));
                    n[6] = texture2D(tDiffuse, vUv + vec2( -w,  h));
                    n[7] = texture2D(tDiffuse, vUv + vec2(0.0,  h));
                    n[8] = texture2D(tDiffuse, vUv + vec2(  w,  h));

                    vec4 sobel_edge_h = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);
                    vec4 sobel_edge_v = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);
                    vec4 sobel = sqrt((sobel_edge_h * sobel_edge_h) + (sobel_edge_v * sobel_edge_v));

                    float intensity = 1.0 - length(sobel.rgb); // ì—£ì§€ë¥¼ ê²€ê²Œ, ë°°ê²½ì„ í¬ê²Œ
                    
                    // Contrast ì¡°ì ˆ
                    intensity = smoothstep(0.4, 0.9, intensity);

                    gl_FragColor = vec4(vec3(intensity), 1.0);
                } else {
                    gl_FragColor = color;
                }
            }
        `;

        const uniforms = {
            tDiffuse: { value: null },
            uIsLineArt: { value: 0.0 },
            uResolution: { value: new THREE.Vector2(640, 480) }
        };

        const material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            side: THREE.DoubleSide
        });

        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // ì´ˆê¸° í”Œë ˆì´ìŠ¤í™€ë” í…ìŠ¤ì²˜ (ê²€ì€ìƒ‰)
        const placeholderCanvas = document.createElement('canvas');
        placeholderCanvas.width = 640; placeholderCanvas.height = 480;
        const ctx = placeholderCanvas.getContext('2d');
        ctx.fillStyle = '#333'; ctx.fillRect(0,0,640,480);
        ctx.fillStyle = '#fff'; ctx.font = '30px sans-serif'; ctx.textAlign = 'center';
        ctx.fillText("Ready to Capture", 320, 240);
        
        const initialTexture = new THREE.CanvasTexture(placeholderCanvas);
        uniforms.tDiffuse.value = initialTexture;

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ ëŒ€ì‘
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- 3. MediaPipe Hands (ì œìŠ¤ì²˜ ì¸ì‹) ---
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.8,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // ì›¹ìº  ì‹¤í–‰
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        cameraUtils.start();

        // ì† ì¸ì‹ ê²°ê³¼ ì²˜ë¦¬
        let palmDetectedTime = 0;
        
        function onResults(results) {
            if (isCountingDown) return; // ì¹´ìš´íŠ¸ë‹¤ìš´ ì¤‘ì´ë©´ ë¬´ì‹œ

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // ì†ì´ ê°ì§€ë¨
                // ê°„ë‹¨íˆ ì†ë°”ë‹¥ì´ ë³´ì´ëŠ”ì§€ í™•ì¸ (ì—„ì§€ì™€ ìƒˆë¼ ì†ê°€ë½ ê±°ë¦¬ ë“± ë³µì¡í•œ ê³„ì‚° ëŒ€ì‹  ë‹¨ìˆœíˆ ì† ê°ì§€ë¡œ íŠ¸ë¦¬ê±°)
                // UXë¥¼ ìœ„í•´ 'ì†ì„ í´ê³  ë©ˆì¶°ìˆì„ ë•Œ' ì¸ì‹í•˜ë©´ ë” ì¢‹ì§€ë§Œ, ì—¬ê¸°ì„  ì¸ì‹ ì¦‰ì‹œ ì¹´ìš´íŠ¸ë‹¤ìš´
                startCountdown();
            }
        }

        // --- 4. ë¡œì§ êµ¬í˜„ (ì¹´ìš´íŠ¸ë‹¤ìš´ ë° ìº¡ì²˜) ---
        function startCountdown() {
            if (isCountingDown) return;
            isCountingDown = true;
            countdownElement.style.display = 'flex';
            
            let count = 3;
            countdownElement.innerText = count;

            const timer = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownElement.innerText = count;
                } else {
                    clearInterval(timer);
                    countdownElement.style.display = 'none';
                    capturePhoto();
                    // ì‚¬ì§„ ì°ê³  ì ì‹œ ì¿¨íƒ€ì„ (ì—°ì† ì´¬ì˜ ë°©ì§€)
                    setTimeout(() => { isCountingDown = false; }, 2000);
                }
            }, 1000);
        }

        function capturePhoto() {
            // ë¹„ë””ì˜¤ í”„ë ˆì„ì„ ìº”ë²„ìŠ¤ì— ê·¸ë¦¼
            const captureCanvas = document.createElement('canvas');
            captureCanvas.width = videoElement.videoWidth;
            captureCanvas.height = videoElement.videoHeight;
            const captureCtx = captureCanvas.getContext('2d');
            
            // ê±°ìš¸ ëª¨ë“œ ë³´ì • (ì¢Œìš° ë°˜ì „)
            captureCtx.translate(captureCanvas.width, 0);
            captureCtx.scale(-1, 1);
            captureCtx.drawImage(videoElement, 0, 0, captureCanvas.width, captureCanvas.height);

            // Three.js í…ìŠ¤ì²˜ë¡œ ì—…ë°ì´íŠ¸
            if (capturedTexture) capturedTexture.dispose();
            capturedTexture = new THREE.CanvasTexture(captureCanvas);
            capturedTexture.minFilter = THREE.LinearFilter;
            capturedTexture.magFilter = THREE.LinearFilter;
            
            uniforms.tDiffuse.value = capturedTexture;
            uniforms.uResolution.value.set(captureCanvas.width, captureCanvas.height);
            
            console.log("Photo Captured!");
        }

        // --- 5. UI ë²„íŠ¼ ì´ë²¤íŠ¸ ---
        
        // ëª¨ë“œ ì „í™˜ (ì»¬ëŸ¬ <-> ì„ í™”)
        toggleBtn.addEventListener('click', () => {
            isLineArtMode = !isLineArtMode;
            uniforms.uIsLineArt.value = isLineArtMode ? 1.0 : 0.0;
            toggleBtn.innerText = isLineArtMode ? "ğŸ¨ ì»¬ëŸ¬ ëª¨ë“œ ì „í™˜" : "ğŸ¨ ì„ í™” ëª¨ë“œ ì „í™˜";
        });

        // ì €ì¥í•˜ê¸°
        saveBtn.addEventListener('click', () => {
            // í˜„ì¬ Three.js ìº”ë²„ìŠ¤ ë‚´ìš©ì„ ì´ë¯¸ì§€ë¡œ ì €ì¥
            renderer.render(scene, camera); // ì €ì¥ ì „ ê°•ì œ ë Œë”ë§
            const dataURL = renderer.domElement.toDataURL("image/png");
            
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = `drawing_ref_${Date.now()}.png`;
            link.click();
        });

    </script>
</body>
</html>