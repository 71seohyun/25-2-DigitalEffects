<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ë“œë¡œì‰ ìë£Œ ìƒì„±ê¸° (2D Enhanced)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: 'Pretendard', sans-serif; }
        
        /* ë©”ì¸ ì»¨í…Œì´ë„ˆ */
        #container { position: relative; width: 100vw; height: 100vh; }
        
        /* ì›¹ìº  ì˜¤ë²„ë ˆì´ (ì¢Œì¸¡ ìƒë‹¨) */
        #webcam-wrapper { 
            position: absolute; top: 20px; left: 20px; z-index: 10; 
            width: 240px; height: 180px; 
            border: 3px solid rgba(255,255,255,0.8); 
            border-radius: 12px; overflow: hidden; background: #000; 
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        #input_video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        
        /* ì¹´ìš´íŠ¸ë‹¤ìš´ í…ìŠ¤íŠ¸ */
        #countdown-text { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 80px; color: #fff; font-weight: 900; 
            text-shadow: 0 0 10px rgba(0,0,0,0.8); display: none; pointer-events: none; z-index: 100;
        }

        /* ë·°ì–´ ì˜ì—­ (Three.js Canvas) */
        #canvas-container { width: 100%; height: 100%; background-color: #333; cursor: grab; }
        #canvas-container:active { cursor: grabbing; }

        /* í•˜ë‹¨ ì»¨íŠ¸ë¡¤ íŒ¨ë„ */
        #controls { 
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); 
            display: flex; gap: 15px; z-index: 20; 
            background: rgba(30,30,30,0.8); padding: 15px 25px; 
            border-radius: 50px; backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        }
        
        button { 
            padding: 12px 24px; border: none; border-radius: 25px; 
            font-size: 15px; cursor: pointer; transition: 0.2s; font-weight: bold; 
            color: white; outline: none;
        }
        button:active { transform: scale(0.95); }

        #btn-mode { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        #btn-save { background: linear-gradient(135deg, #ff6a00 0%, #ee0979 100%); }
        #status-msg {
            position: absolute; top: 20px; right: 20px;
            color: rgba(255,255,255,0.7); font-size: 14px;
            background: rgba(0,0,0,0.5); padding: 8px 12px; border-radius: 8px;
            pointer-events: none;
        }

    </style>
</head>
<body>

    <div id="countdown-text">3</div>
    <div id="status-msg">íœ : í™•ëŒ€/ì¶•ì†Œ | ë“œë˜ê·¸: ì´ë™</div>

    <!-- ì›¹ìº  ì˜ì—­ -->
    <div id="webcam-wrapper">
        <video id="input_video" autoplay playsinline></video>
    </div>

    <!-- ë·°ì–´ ì˜ì—­ -->
    <div id="canvas-container"></div>

    <!-- ë²„íŠ¼ë“¤ -->
    <div id="controls">
        <button id="btn-mode">ğŸ¨ ëª¨ë“œ ë³€ê²½ (ê¸°ë³¸)</button>
        <button id="btn-save">ğŸ’¾ ì´ë¯¸ì§€ ì €ì¥</button>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        // --- 1. ì„¤ì • ë° ë³€ìˆ˜ ---
        const videoElement = document.getElementById('input_video');
        const countdownEl = document.getElementById('countdown-text');
        const btnMode = document.getElementById('btn-mode');
        const btnSave = document.getElementById('btn-save');
        const container = document.getElementById('canvas-container');

        let isCountingDown = false;
        let currentMode = 0; // 0: Normal, 1: LineArt, 2: Posterize
        const modeNames = ["ê¸°ë³¸", "ì„ í™” (ê¹”ë”)", "í¬ìŠ¤í„°ë¼ì´ì¦ˆ"];
        
        // --- 2. Three.js (2D ë·°ì–´ ëª¨ë“œ) ì„¤ì • ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222); // ë°°ê²½ìƒ‰

        // OrthographicCamera ì‚¬ìš© (ì›ê·¼ê° ì—†ëŠ” 2D ì¹´ë©”ë¼)
        // í™”ë©´ í¬ê¸°ì— ë§ì¶° ì ˆë‘ì²´ ì„¤ì •
        const aspect = window.innerWidth / window.innerHeight;
        const frustumSize = 2; // ë³´ì—¬ì§ˆ ë†’ì´ í¬ê¸° (ì„ì˜ ì„¤ì •)
        const camera = new THREE.OrthographicCamera(
            frustumSize * aspect / -2, frustumSize * aspect / 2, 
            frustumSize / 2, frustumSize / -2, 
            0.1, 1000
        );
        camera.position.z = 10;
        camera.zoom = 1; // ì¤Œ ë ˆë²¨

        const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        // ì´ë¯¸ì§€ í‰ë©´ (Geometry)
        const geometry = new THREE.PlaneGeometry(1, 1); // í…ìŠ¤ì²˜ ë¡œë“œ ì‹œ ë¹„ìœ¨ ì¡°ì • ì˜ˆì •

        // --- 3. ì‰ì´ë” (GLSL) ì‘ì„± ---
        // í…ìŠ¤ì²˜ ì¢Œí‘œë§Œ ë„˜ê¸°ëŠ” ê¸°ë³¸ ë²„í…ìŠ¤ ì‰ì´ë”
        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        // í•µì‹¬ í”„ë˜ê·¸ë¨¼íŠ¸ ì‰ì´ë” (ì„ í™” ê°œì„  ë° í¬ìŠ¤í„°ë¼ì´ì¦ˆ)
        const fragmentShader = `
            uniform sampler2D tDiffuse;
            uniform int uMode; // 0: Normal, 1: Line, 2: Posterize
            uniform vec2 uResolution;
            varying vec2 vUv;

            // ê·¸ë ˆì´ìŠ¤ì¼€ì¼ ë³€í™˜ í•¨ìˆ˜
            float getLuminance(vec3 color) {
                return dot(color, vec3(0.299, 0.587, 0.114));
            }

            void main() {
                vec4 texColor = texture2D(tDiffuse, vUv);

                if (uMode == 1) { 
                    // [ëª¨ë“œ 1: ê¹”ë”í•œ ì„ í™”]
                    
                    float w = 1.0 / uResolution.x;
                    float h = 1.0 / uResolution.y;
                    
                    // 1. Sobel Edge Detection (ì£¼ë³€ í”½ì…€ ìƒ˜í”Œë§)
                    // ì•½ê°„ ë„“ê²Œ ìƒ˜í”Œë§í•˜ì—¬ ìì˜í•œ ë…¸ì´ì¦ˆ ë¬´ì‹œ (step 1.5)
                    float step = 1.5; 
                    
                    float tl = getLuminance(texture2D(tDiffuse, vUv + vec2(-w, -h) * step).rgb);
                    float t  = getLuminance(texture2D(tDiffuse, vUv + vec2( 0, -h) * step).rgb);
                    float tr = getLuminance(texture2D(tDiffuse, vUv + vec2( w, -h) * step).rgb);
                    float l  = getLuminance(texture2D(tDiffuse, vUv + vec2(-w,  0) * step).rgb);
                    float r  = getLuminance(texture2D(tDiffuse, vUv + vec2( w,  0) * step).rgb);
                    float bl = getLuminance(texture2D(tDiffuse, vUv + vec2(-w,  h) * step).rgb);
                    float b  = getLuminance(texture2D(tDiffuse, vUv + vec2( 0,  h) * step).rgb);
                    float br = getLuminance(texture2D(tDiffuse, vUv + vec2( w,  h) * step).rgb);

                    float x = (tr + 2.0 * r + br) - (tl + 2.0 * l + bl);
                    float y = (bl + 2.0 * b + br) - (tl + 2.0 * t + tr);
                    
                    float edge = sqrt(x*x + y*y);

                    // 2. Thresholding (ì„ê³„ê°’ ì ìš©)
                    // edge ê°’ì´ 0.15ë³´ë‹¤ ì‘ìœ¼ë©´ 0(í°ìƒ‰ ë°°ê²½ì´ ë¨), í¬ë©´ ì§„í•˜ê²Œ
                    // smoothstepìœ¼ë¡œ ê²½ê³„ë¥¼ ë¶€ë“œëŸ½ì§€ë§Œ ë‹¨ë‹¨í•˜ê²Œ ë§Œë“¦
                    float line = smoothstep(0.1, 0.3, edge);

                    // 3. ë°˜ì „ (ê²€ì€ ë°°ê²½->í°ì„  => í° ë°°ê²½->ê²€ì€ì„ )
                    vec3 finalColor = vec3(1.0 - line);

                    gl_FragColor = vec4(finalColor, 1.0);

                } else if (uMode == 2) { 
                    // [ëª¨ë“œ 2: í¬ìŠ¤í„°ë¼ì´ì¦ˆ (ìƒ‰ìƒ ë‹¨ìˆœí™”)]
                    
                    float levels = 5.0; // ìƒ‰ìƒ ë‹¨ê³„ ìˆ˜
                    vec3 c = texColor.rgb;
                    
                    // ê°ë§ˆ ë³´ì • ëŠë‚Œìœ¼ë¡œ ì±„ë„ë¥¼ ì•½ê°„ ì˜¬ë¦° í›„ ë‹¨ê³„í™”í•˜ë©´ ë” ì˜ˆì¨
                    // c = pow(c, vec3(0.8)); 

                    c = floor(c * levels) / levels;
                    
                    gl_FragColor = vec4(c, 1.0);

                } else {
                    // [ëª¨ë“œ 0: ê¸°ë³¸]
                    gl_FragColor = texColor;
                }
            }
        `;

        const uniforms = {
            tDiffuse: { value: null },
            uMode: { value: 0 },
            uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
        };

        const material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            side: THREE.DoubleSide
        });

        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // ì´ˆê¸° ì•ˆë‚´ìš© í…ìŠ¤ì²˜
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = 640; tempCanvas.height = 480;
        const tCtx = tempCanvas.getContext('2d');
        tCtx.fillStyle = '#111'; tCtx.fillRect(0,0,640,480);
        tCtx.fillStyle = '#888'; tCtx.font = 'bold 30px sans-serif'; tCtx.textAlign = 'center'; tCtx.textBaseline = 'middle';
        tCtx.fillText("ì›¹ìº ì— ì†ë°”ë‹¥ì„ ë³´ì—¬ì£¼ì„¸ìš”", 320, 240);
        const initialTex = new THREE.CanvasTexture(tempCanvas);
        uniforms.tDiffuse.value = initialTex;
        mesh.scale.set(1.33, 1, 1); // 4:3 ë¹„ìœ¨

        // --- 4. ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ (Pan & Zoom) ---
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        container.addEventListener('mousedown', (e) => { isDragging = true; previousMousePosition = { x: e.clientX, y: e.clientY }; });
        window.addEventListener('mouseup', () => { isDragging = false; });
        
        container.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaMove = { x: e.clientX - previousMousePosition.x, y: e.clientY - previousMousePosition.y };
                
                // Pan ì´ë™ (Zoom ë ˆë²¨ì— ë”°ë¼ ì†ë„ ì¡°ì ˆ)
                const moveSpeed = 0.002 / camera.zoom; 
                camera.position.x -= deltaMove.x * moveSpeed * (window.innerWidth/window.innerHeight);
                camera.position.y += deltaMove.y * moveSpeed; 
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        container.addEventListener('wheel', (e) => {
            const zoomSpeed = 0.001;
            camera.zoom += e.deltaY * -zoomSpeed * camera.zoom; // í˜„ì¬ ì¤Œ ë¹„ë¡€ í™•ëŒ€/ì¶•ì†Œ
            camera.zoom = Math.max(0.1, Math.min(camera.zoom, 10)); // ì¤Œ ì œí•œ
            camera.updateProjectionMatrix();
        });

        // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -frustumSize * aspect / 2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = -frustumSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();


        // --- 5. MediaPipe & ë¡œì§ ---
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.8, minTrackingConfidence: 0.5 });
        
        hands.onResults((results) => {
            if (!isCountingDown && results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                startCountdown();
            }
        });

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraUtils.start();

        function startCountdown() {
            isCountingDown = true;
            countdownEl.style.display = 'block';
            let count = 3;
            countdownEl.innerText = count;

            const timer = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownEl.innerText = count;
                } else {
                    clearInterval(timer);
                    countdownEl.style.display = 'none';
                    capturePhoto();
                    // ì¿¨íƒ€ì„
                    setTimeout(() => { isCountingDown = false; }, 2500);
                }
            }, 1000);
        }

        function capturePhoto() {
            // ìº”ë²„ìŠ¤ì— í˜„ì¬ í”„ë ˆì„ ìº¡ì²˜
            const captureCanvas = document.createElement('canvas');
            captureCanvas.width = videoElement.videoWidth;
            captureCanvas.height = videoElement.videoHeight;
            const ctx = captureCanvas.getContext('2d');
            
            // ì¢Œìš° ë°˜ì „ (ê±°ìš¸ ëª¨ë“œ ë³´ì •)
            ctx.translate(captureCanvas.width, 0);
            ctx.scale(-1, 1);
            ctx.drawImage(videoElement, 0, 0);

            // Three.js í…ìŠ¤ì²˜ ì—…ë°ì´íŠ¸
            const newTexture = new THREE.CanvasTexture(captureCanvas);
            newTexture.minFilter = THREE.LinearFilter;
            newTexture.magFilter = THREE.LinearFilter;
            
            uniforms.tDiffuse.value = newTexture;
            uniforms.uResolution.value.set(captureCanvas.width, captureCanvas.height);

            // ì´ë¯¸ì§€ ë¹„ìœ¨ì— ë§ì¶° Mesh í¬ê¸° ì¡°ì ˆ
            const imgAspect = captureCanvas.width / captureCanvas.height;
            mesh.scale.set(imgAspect, 1, 1);
            
            // ì¹´ë©”ë¼ ë° ìœ„ì¹˜ ì´ˆê¸°í™” (ë³´ê¸° ì¢‹ê²Œ)
            camera.zoom = 1.0; // ê½‰ ì°¨ê²Œ ë³´ì´ë„ë¡ ì¡°ì •
            camera.position.set(0,0,10);
            camera.updateProjectionMatrix();

            console.log("Captured!");
        }

        // --- 6. ë²„íŠ¼ ì´ë²¤íŠ¸ ---
        btnMode.addEventListener('click', () => {
            currentMode = (currentMode + 1) % 3;
            uniforms.uMode.value = currentMode;
            btnMode.innerText = `ğŸ¨ ëª¨ë“œ: ${modeNames[currentMode]}`;
        });

        btnSave.addEventListener('click', () => {
            renderer.render(scene, camera);
            const link = document.createElement('a');
            link.download = `ref_image_${modeNames[currentMode]}_${Date.now()}.png`;
            link.href = renderer.domElement.toDataURL("image/png");
            link.click();
        });

    </script>
</body>
</html>